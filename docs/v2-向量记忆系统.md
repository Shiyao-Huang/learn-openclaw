# V2: 本地向量记忆系统

**从 V1 的无状态到 V2 的长期记忆（`v2-agent.ts` 481 行）**

V2 的关键不是接入外部向量库，而是先把“可搜索、可持久化、可增量更新”的记忆闭环做出来。

- 记忆目录: `.memory/`
- 索引文件: `.memory/index.json`
- 相似度: Jaccard
- 分词: 中文 2-gram + 英文单词

---

## V1 vs V2

| 维度 | V1 | V2 |
|---|---|---|
| 工具数 | 5 | 10 |
| 记忆能力 | 无 | 本地长期记忆 |
| 外部依赖 | 无 | 无（零外部 DB） |
| 主要新增工具 | - | `memory_search/get/append/ingest/stats` |
| 代码规模 | 310 行 | 481 行 |

---

## 核心实现

### 1. LocalMemory

```typescript
class LocalMemory {
  private chunks: MemoryChunk[] = [];
  private memoryDir = path.join(WORKDIR, ".memory");
  private indexFile = path.join(this.memoryDir, "index.json");
}
```

每个分块包含：

- `id`: chunk 哈希
- `content`: 文本内容
- `source`: 来源文件
- `tokens`: 分词集合

### 2. 语义检索流程

```text
query -> tokenize -> jaccard(chunk.tokens) -> score 排序 -> topK 返回
```

检索阈值是 `score > 0.05`，避免低质量噪音。

### 3. 写入与索引

- `memory_append`: 追加文本并即时索引
- `memory_ingest`: 批量摄入文件/目录并切分 chunk
- `memory_stats`: 查看 chunk 统计

---

## 5 个记忆工具

```typescript
memory_search(query, max_results?)
memory_get(path, from_line?, lines?)
memory_append(path, content)
memory_ingest(path)
memory_stats()
```

结合 V1 的基础工具后，V2 一共 10 个工具。

---

## 与代码保持一致的细节

1. 记忆路径在 `.memory/`，不是 `memory/`。
2. V2 没有 ChromaDB / Qdrant / Pinecone。
3. `memory_ingest` 支持文件和目录：目录只 ingest 顶层匹配扩展名文件（`md/txt/ts/js/py`）。
4. `memory_get` 支持按行读取（`from_line` + `lines`）。

---

## 最小验证

```bash
npx tsx v2-agent.ts
```

示例命令：

```text
>> 先把 docs 目录摄入记忆
[memory_ingest] {"path":"docs"}

>> 搜索“任务规划”
[memory_search] {"query":"任务规划"}

>> 记录今天的决定
[memory_append] {"path":"notes.md","content":"决定先补齐 v2-v9 文档一致性"}

>> 查看记忆库统计
[memory_stats] {}
```

---

## 演进意义

V2 建立了后续所有版本都在复用的基础：

- 检索先于行动（`recall -> think -> act`）
- 记忆可累积（跨会话）
- 记忆可维护（append/ingest/stats）

下一步 V3 才能在“有记忆”的前提上做显式任务规划。

---

[← V1: 模型即代理](./v1-模型即代理.md) | [V3: 任务规划系统 →](./v3-任务规划系统.md)
