# V2: 向量记忆系统

**从 V1 的无状态到 V2 的长期记忆 (~500行)**

V1 能读写文件，但每次重启后"忘记"了一切。V2 添加向量记忆，让 Agent 拥有跨会话的长期记忆。

---

## V1 vs V2

| 特性 | V1 | V2 |
|------|-----|-----|
| 工具数量 | 5 | 9 (+4 memory) |
| 会话状态 | 无状态 | 向量记忆 |
| 知识检索 | 无 | 语义搜索 |
| 跨会话记忆 | 否 | 是 |
| 代码行数 | ~300 | ~500 |
| 依赖 | 仅 SDK | SDK + ChromaDB |

---

## 记忆工作流程

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  文档摄入    │────▶│  向量数据库  │────▶│  语义搜索   │
│  MEMORY.md  │     │  ChromaDB   │     │  相关知识   │
└─────────────┘     └─────────────┘     └──────┬──────┘
                                                │
                                                ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  记录决策   │◀────│  Agent 思考  │◀────│  注入 Prompt│
│ memory_append│    │             │     │             │
└─────────────┘     └─────────────┘     └─────────────┘
```

**工作循环**: `recall -> think -> act -> (optional) remember`

---

## 四个记忆工具

```typescript
// 1. memory_search - 语义搜索长期记忆
{
  name: "memory_search",
  description: "语义搜索长期记忆。查询前先搜索相关知识",
  input_schema: {
    properties: {
      query: { type: "string", description: "搜索查询" },
      max_results: { type: "number", description: "最大结果数 (默认 5)" }
    },
    required: ["query"]
  }
}

// 2. memory_get - 读取原始文件
{
  name: "memory_get",
  description: "读取记忆文件的原始内容",
  input_schema: {
    properties: {
      path: { type: "string", description: "记忆文件路径" },
      from_line: { type: "number", description: "起始行号 (可选)" },
      lines: { type: "number", description: "读取行数 (可选)" }
    },
    required: ["path"]
  }
}

// 3. memory_append - 追加到记忆
{
  name: "memory_append",
  description: "追加内容到记忆文件，自动重新索引",
  input_schema: {
    properties: {
      path: { type: "string", description: "记忆文件路径" },
      content: { type: "string", description: "要记录的内容" }
    },
    required: ["path", "content"]
  }
}

// 4. memory_ingest - 摄入文件到向量库
{
  name: "memory_ingest",
  description: "摄入文件或目录到向量库",
  input_schema: {
    properties: {
      path: { type: "string", description: "文件或目录路径" }
    },
    required: ["path"]
  }
}
```

---

## MemoryManager 核心实现

```typescript
class MemoryManager {
  private collection: any = null;
  private memoryDir: string;

  constructor() {
    this.memoryDir = path.join(WORKDIR, "memory");
    this.init();
  }

  async init() {
    // 连接 ChromaDB
    this.collection = await chroma.getOrCreateCollection({
      name: COLLECTION_NAME,
      metadata: { description: "OpenClaw V2 Memory" }
    });

    // 自动摄入 memory/ 目录
    if (fs.existsSync(this.memoryDir)) {
      await this.ingestDirectory(this.memoryDir);
    }
  }

  // 语义搜索
  async search(query: string, maxResults = 5): Promise<string> {
    const results = await this.collection.query({
      queryEmbeddings: [simpleEmbedding(query)],
      nResults: maxResults
    });

    return results.documents[0]
      .map((doc: string, i: number) => {
        const meta = results.metadatas[0][i];
        return `[${meta.source}:${meta.chunk}] ${doc.slice(0, 200)}...`;
      })
      .join("\n\n");
  }

  // 追加并自动重新索引
  append(filePath: string, content: string): string {
    // ... 写入文件
    // 自动重新摄入
    this.ingestFile(fullPath).catch(console.error);
    return `已追加到: ${filePath}`;
  }
}
```

---

## 简单 Embedding 实现

生产环境使用 OpenAI/Ollama，V2 使用简单的词频向量：

```typescript
function simpleEmbedding(text: string): number[] {
  const words = text.toLowerCase().split(/\s+/);
  const vocab = Array.from(new Set(words)).sort();
  return vocab.map(w => words.filter(x => x === w).length / words.length);
}
```

**原理**: 词频向量足以演示语义搜索的概念，生产环境应使用 `text-embedding-3-small` 或类似模型。

---

## 启动 ChromaDB

```bash
# Docker 启动
docker run -p 8000:8000 chromadb/chroma

# 或使用 docker-compose
docker-compose up -d chroma
```

---

## 使用示例

### 1. 创建记忆文件

```bash
mkdir -p memory
cat > memory/project.md << 'EOF'
# 项目知识

## 技术栈
- 前端: React + TypeScript
- 后端: Node.js + Express
- 数据库: PostgreSQL

## 命名规范
- 组件: PascalCase (如 UserCard)
- 函数: camelCase (如 getUserData)
- 常量: UPPER_SNAKE_CASE
EOF
```

### 2. 运行 V2 Agent

```bash
npx tsx v2_openclaw_agent.ts
```

### 3. 测试记忆功能

```
>> 我们项目用什么数据库？
[memory_search] {"query": "数据库"}
[project.md:1] ## 技术栈...

我们项目使用 PostgreSQL 作为数据库。

>> 记录一个新的决策: 使用 Redis 做缓存
[memory_append] {"path": "decisions.md", "content": "使用 Redis 做会话缓存"}
已追加到: decisions.md
```

---

## V2 与 OpenClaw 的映射

| V2 概念 | OpenClaw 真实文件 | 说明 |
|---------|-------------------|------|
| `MemoryManager` | `src/sessions/session-memory.ts` | Session 级记忆管理 |
| `memory_search` | Qdrant/QMD 查询 | 语义搜索实现 |
| `simpleEmbedding` | `@mariozechner/pi-ai` 的 embedding | 向量生成 |
| `memory/` 目录 | `~/.openclaw/sessions/` | 持久化存储 |
| 自动摄入 | `session-ingest-tool.ts` | 文档摄入工具 |

---

## 运行 V2

```bash
cd /Users/swmt/work/deepwork/learn-openclaw

# 1. 启动 ChromaDB
docker run -p 8000:8000 chromadb/chroma

# 2. 交互模式
npx tsx v2_openclaw_agent.ts

# 3. 直接执行
npx tsx v2_openclaw_agent.ts "搜索关于数据库的记忆"
```

---

## 核心洞察

**Agent 需要长期记忆，就像人类需要笔记一样。**

V2 的记忆系统让 Agent 能够：
- 记住之前的决策和知识
- 跨会话保持上下文
- 通过语义搜索快速检索相关信息

这就是 OpenClaw 等现代 Agent 系统的核心能力之一。

---

[← V1: 模型即代理](./v1-模型即代理.md) | [V3: 子代理编排 →](./v3-子代理编排.md)
