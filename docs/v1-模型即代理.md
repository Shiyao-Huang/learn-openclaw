# V1: 模型即代理

**从 V0 的单一工具到 V1 的完整工具系统 (~300行)**

V0 证明了单个 `bash` 工具足够。V1 展示更实用的设计：专用工具提供更好的错误处理和安全性。

---

## V0 vs V1

| 特性 | V0 | V1 |
|------|-----|-----|
| 工具数量 | 1 (bash) | 4 (bash, read, write, grep) |
| 文件读取 | `cat file` | `read_file` 工具 |
| 文件写入 | `echo '...' > file` | `write_file` 工具 |
| 搜索 | `grep pattern` | `grep` 工具 |
| 代码行数 | ~150 | ~300 |
| 适用场景 | 概念验证 | 实际编码任务 |

---

## 四个核心工具

```typescript
const TOOLS = [
  // 1. bash - 执行任意命令
  {
    name: "bash",
    description: "执行 shell 命令。用于: ls, find, git, npm 等",
    input_schema: {
      type: "object",
      properties: { command: { type: "string" } },
      required: ["command"]
    }
  },

  // 2. read_file - 读取文件
  {
    name: "read_file",
    description: "读取文件内容。支持可选的行数限制",
    input_schema: {
      type: "object",
      properties: {
        path: { type: "string" },
        limit: { type: "number" }  // 可选
      },
      required: ["path"]
    }
  },

  // 3. write_file - 写入文件
  {
    name: "write_file",
    description: "写入文件内容。自动创建父目录",
    input_schema: {
      type: "object",
      properties: {
        path: { type: "string" },
        content: { type: "string" }
      },
      required: ["path", "content"]
    }
  },

  // 4. grep - 搜索文件
  {
    name: "grep",
    description: "在文件中搜索文本。支持正则表达式",
    input_schema: {
      type: "object",
      properties: {
        pattern: { type: "string" },
        path: { type: "string" },
        recursive: { type: "boolean" }  // 可选，默认 true
      },
      required: ["pattern", "path"]
    }
  }
];
```

---

## 工具实现对比

### V0: 通过 bash 完成所有操作

```typescript
// V0 - 使用 bash 读取文件
const result = execSync("cat src/main.ts", { encoding: "utf-8" });

// V0 - 使用 bash 写入文件
const result = execSync("echo 'content' > file.txt", { encoding: "utf-8" });

// V0 - 使用 bash 搜索
const result = execSync("grep -r 'pattern' src/", { encoding: "utf-8" });
```

### V1: 专用工具

```typescript
// V1 - 专用 read_file 工具
function runRead(path: string, limit?: number): string {
  const content = fs.readFileSync(path, "utf-8");
  if (limit) return content.split("\n").slice(0, limit).join("\n");
  return content;
}

// V1 - 专用 write_file 工具
function runWrite(path: string, content: string): string {
  fs.mkdirSync(path.dirname(path), { recursive: true });
  fs.writeFileSync(path, content);
  return "已写入";
}

// V1 - 专用 grep 工具
function runGrep(pattern: string, path: string, recursive?: boolean): string {
  const cmd = recursive
    ? `find "${path}" -type f -exec grep -l "${pattern}" {} +`
    : `grep -l "${pattern}" "${path}"/*`;
  return execSync(cmd, { encoding: "utf-8" });
}
```

---

## 安全改进

V1 添加了路径安全检查：

```typescript
function safePath(p: string): string {
  const resolved = path.resolve(WORKDIR, p);
  const relative = path.relative(WORKDIR, resolved);

  // 防止路径遍历攻击
  if (relative.startsWith("..") || path.isAbsolute(relative)) {
    throw new Error(`路径超出工作区: ${p}`);
  }
  return resolved;
}
```

---

## V1 与 OpenClaw 的映射

| V1 概念 | OpenClaw 真实文件 | 说明 |
|---------|-------------------|------|
| `read_file` 工具 | `@mariozechner/pi-coding-agent` 的 `createReadTool()` | 文件读取实现 |
| `write_file` 工具 | `createWriteTool()` | 文件写入实现 |
| `bash` 工具 | `src/agents/bash-tools.ts` | 命令执行 |
| 路径安全检查 | `safePath()` 在 `pi-tools.read.ts` | 沙箱安全 |
| 工具注册 | `createOpenClawCodingTools()` | 工具组装 |

---

## 运行 V1

```bash
cd /Users/swmt/work/deepwork/learn-openclaw

# 交互模式
npx tsx v1_openclaw_agent.ts

# 直接执行
npx tsx v1_openclaw_agent.ts "读取 v0_openclaw_agent.ts 的前 30 行"
```

---

## 核心洞察

**模型是决策者，代码只提供工具。**

模型决定：
- 调用哪些工具
- 以什么顺序调用
- 何时停止

代码只负责：
- 提供工具定义
- 执行工具调用
- 维护对话历史

这就是 Agent 系统的全部秘密。

---

[← V0: Bash 即一切](./v0-Bash即一切.md) | [V2: Session 管理 →](./v2-Session管理.md)
