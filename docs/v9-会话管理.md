# V9: 会话管理系统

> **核心哲学**: "一个 Agent 可以同时服务多个用户/上下文"

## 为什么需要会话管理？

V8 的 Agent 有了主动性，但所有交互都在同一个会话中。问题：

1. **单一上下文**: 无法同时处理多个独立任务
2. **隐私混淆**: 不同用户/场景的信息可能混在一起
3. **无法隔离**: 敏感操作和普通操作共享同一上下文

V9 引入会话管理：
- **多会话支持**: 同时维护多个独立会话
- **会话类型**: main（完整记忆）vs isolated（轻量隔离）
- **会话持久化**: 会话可以保存和恢复

---

## 核心设计

### 两种会话类型

| 类型 | 特点 | 适用场景 |
|------|------|---------|
| `main` | 加载完整记忆、人格、敏感信息 | 主用户交互 |
| `isolated` | 轻量运行，不加载敏感记忆 | 临时任务、外部请求 |

### Session 接口

```typescript
type SessionType = "main" | "isolated";

interface Session {
  key: string;                          // 唯一标识
  type: SessionType;                    // 会话类型
  history: Anthropic.MessageParam[];    // 对话历史
  createdAt: number;                    // 创建时间
  lastActiveAt: number;                 // 最后活跃时间
  metadata: Record<string, any>;        // 自定义元数据
}
```

### SessionManager 类

```typescript
class SessionManager {
  private sessions: Map<string, Session> = new Map();
  private workspaceDir: string;
  private sessionsDir: string;

  constructor(workspaceDir: string) {
    this.workspaceDir = workspaceDir;
    this.sessionsDir = path.join(workspaceDir, ".sessions");
    if (!fs.existsSync(this.sessionsDir)) {
      fs.mkdirSync(this.sessionsDir, { recursive: true });
    }
    this.loadSessions();
  }

  // 生成会话 key
  private generateKey(): string {
    return `session_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }

  // 创建新会话
  createSession(type: SessionType = "main", metadata: Record<string, any> = {}): Session {
    const session: Session = {
      key: this.generateKey(),
      type,
      history: [],
      createdAt: Date.now(),
      lastActiveAt: Date.now(),
      metadata
    };
    this.sessions.set(session.key, session);
    this.saveSession(session);
    return session;
  }

  // 获取会话
  getSession(key: string): Session | undefined {
    const session = this.sessions.get(key);
    if (session) {
      session.lastActiveAt = Date.now();
    }
    return session;
  }

  // 获取或创建会话
  getOrCreateSession(key?: string, type: SessionType = "main"): Session {
    if (key) {
      const existing = this.getSession(key);
      if (existing) return existing;
    }
    return this.createSession(type);
  }

  // 更新会话历史
  updateHistory(key: string, history: Anthropic.MessageParam[]) {
    const session = this.sessions.get(key);
    if (session) {
      session.history = history;
      session.lastActiveAt = Date.now();
      this.saveSession(session);
    }
  }

  // 判断是否是主会话
  isMainSession(key: string): boolean {
    const session = this.sessions.get(key);
    return session?.type === "main";
  }

  // 清理过期会话（超过 7 天）
  cleanupSessions(): string {
    const cutoff = Date.now() - 7 * 24 * 60 * 60 * 1000;
    let cleaned = 0;

    for (const [key, session] of this.sessions) {
      if (session.lastActiveAt < cutoff) {
        this.deleteSession(key);
        cleaned++;
      }
    }

    return `已清理 ${cleaned} 个过期会话`;
  }
}
```

---

## 会话工具

### session_create

```typescript
{
  name: "session_create",
  description: "创建新会话",
  input_schema: {
    type: "object",
    properties: {
      type: { type: "string", enum: ["main", "isolated"], description: "会话类型" },
      metadata: { type: "object", description: "自定义元数据" }
    }
  }
}
```

### session_get

```typescript
{
  name: "session_get",
  description: "获取会话信息",
  input_schema: {
    type: "object",
    properties: {
      key: { type: "string", description: "会话 key" }
    },
    required: ["key"]
  }
}
```

### session_list

```typescript
{
  name: "session_list",
  description: "列出所有会话",
  input_schema: { type: "object", properties: {} }
}
```

### session_delete

```typescript
{
  name: "session_delete",
  description: "删除会话",
  input_schema: {
    type: "object",
    properties: {
      key: { type: "string", description: "会话 key" }
    },
    required: ["key"]
  }
}
```

### session_cleanup

```typescript
{
  name: "session_cleanup",
  description: "清理过期会话",
  input_schema: { type: "object", properties: {} }
}
```

---

## 工作流程示例

### 创建隔离会话处理外部请求

```
[外部 API 请求到达]

Agent: [调用 session_create]
{ type: "isolated", metadata: { source: "api", user: "external_user_123" } }

已创建会话: session_1705123456_abc123 [isolated]

[在隔离会话中处理请求，不访问敏感记忆]
```

### 切换会话上下文

```
用户: 帮我处理一个临时任务，不要影响主会话

Agent: [调用 session_create]
{ type: "isolated" }

已创建隔离会话: session_1705123789_def456

[在隔离会话中执行任务]

Agent: 任务完成。是否要将结果同步到主会话？
```

### 列出和管理会话

```
用户: 有哪些活跃的会话？

Agent: [调用 session_list]

- session_main_001 [main] (5分钟前, 23条消息)
- session_1705123456_abc123 [isolated] (30分钟前, 5条消息)
- session_1705123789_def456 [isolated] (2小时前, 12条消息)

用户: 清理过期的会话

Agent: [调用 session_cleanup]

已清理 3 个过期会话
```

---

## 会话路由机制

V9 的核心是会话路由——根据请求来源决定使用哪个会话：

```typescript
// 会话路由逻辑
async function routeRequest(request: Request) {
  const sessionKey = request.headers["x-session-key"];
  const sessionType = request.headers["x-session-type"] || "main";

  // 获取或创建会话
  const session = sessionManager.getOrCreateSession(sessionKey, sessionType);

  // 根据会话类型决定加载什么
  if (session.type === "main") {
    // 加载完整记忆和人格
    await loadFullContext(session);
  } else {
    // 轻量模式，只加载基本能力
    await loadMinimalContext(session);
  }

  // 在会话上下文中处理请求
  return await processInSession(session, request);
}
```

---

## 文件结构

```
project/
├── .sessions/                    # 会话持久化目录
│   ├── session_main_001.json
│   ├── session_1705123456_abc123.json
│   └── session_1705123789_def456.json
├── memory/
│   └── ...
├── MEMORY.md
├── HEARTBEAT.md
└── ...
```

### 会话文件示例

```json
{
  "key": "session_1705123456_abc123",
  "type": "isolated",
  "history": [
    { "role": "user", "content": "处理这个临时任务" },
    { "role": "assistant", "content": "好的，我来处理..." }
  ],
  "createdAt": 1705123456000,
  "lastActiveAt": 1705125000000,
  "metadata": {
    "source": "api",
    "user": "external_user_123"
  }
}
```

---

## 系统提示的变化

V9 的系统提示包含会话规则：

```typescript
const BASE_SYSTEM = `你是 OpenClaw V9 - 多会话 Agent。

工作循环: route -> heartbeat -> recall -> identify -> plan -> execute -> track -> remember

Session 规则 (V9 新增):
- 每个会话有独立的上下文和历史
- main 会话: 加载完整记忆和人格
- isolated 会话: 轻量运行，不加载敏感信息
- 使用 session_* 工具管理会话

时间感知:
${layeredMemory.getTimeContext()}

心跳规则:
- 收到心跳信号时，读取 HEARTBEAT.md 检查清单
- 执行检查但不打扰用户（深夜静默）
...`;
```

---

## 与 V8 的对比

| 特性 | V8 | V9 |
|------|----|-----|
| 心跳系统 | ✅ | ✅ |
| 多会话 | ❌ 单一会话 | ✅ 多会话管理 |
| 会话隔离 | ❌ | ✅ main vs isolated |
| 会话持久化 | ❌ | ✅ .sessions/ 目录 |
| 会话路由 | ❌ | ✅ 根据来源分发 |

---

## 关键洞察

1. **上下文隔离**: 不同任务/用户需要独立的上下文
2. **隐私分级**: 敏感信息只在主会话中可见
3. **会话生命周期**: 会话需要创建、使用、清理的完整管理
4. **路由优先**: 先确定会话，再执行任务

---

## 演进路线总结

```
V0-V5: 技术能力
├── V0: Bash 即一切
├── V1: 5 工具 + 安全边界
├── V2: 本地记忆
├── V3: 任务规划
├── V4: 子代理协调
└── V5: Skill 系统

V6-V8: 人格能力
├── V6: 身份系统
├── V7: 分层记忆
└── V8: 心跳系统

V9: Session 路由 (当前)
└── 多会话管理

V10: Channel 适配 (下一步)
└── 多渠道接入
```

---

## 下一步

V9 的 Agent 能管理多个会话了，但所有请求都来自同一个入口。V10 将引入 Channel 适配，让 Agent 能接入多个渠道（CLI、API、Webhook、消息平台等）。
