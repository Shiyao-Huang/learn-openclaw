# V4: 子代理协调系统

> **核心哲学**: "Agent 需要协作，但不需要复杂的编排系统"

## 为什么需要子代理？

V3 的 Agent 能规划任务，但所有工作都在同一个上下文中执行。这带来问题：

1. **上下文污染**: 一个任务的中间结果会影响其他任务
2. **无法并行**: 必须串行执行所有任务
3. **错误传播**: 一个任务失败可能影响整个会话

V4 引入子代理，通过**进程递归**实现上下文隔离。

---

## 核心设计

### 进程递归

V4 的子代理不是复杂的编排系统，而是简单的进程递归：

```typescript
function runSubagent(task: string, context?: string): string {
  const scriptPath = fileURLToPath(import.meta.url);
  const fullPrompt = context
    ? `[任务] ${task}\n\n[上下文]\n${context}`
    : task;

  const escapedPrompt = fullPrompt.replace(/"/g, '\\"');
  const cmd = `npx tsx "${scriptPath}" "${escapedPrompt}"`;

  const output = execSync(cmd, {
    encoding: "utf-8",
    timeout: 120000,
    cwd: WORKDIR,
    env: { ...process.env, OPENCLAW_SUBAGENT: "1" }
  });

  return `[子代理完成]\n${output.slice(0, 10000)}`;
}
```

**关键点**:
- 子代理运行**同一个脚本**
- 通过命令行参数传递任务
- 环境变量 `OPENCLAW_SUBAGENT: "1"` 标识子代理身份
- 完全隔离的进程，独立的上下文

### 为什么用进程递归？

| 方案 | 优点 | 缺点 |
|------|------|------|
| 线程 | 快速 | 共享内存，上下文污染 |
| 协程 | 轻量 | 同一进程，难以隔离 |
| **进程** | **完全隔离** | 启动��销 |
| 微服务 | 可扩展 | 复杂度高 |

进程递归是最简单的隔离方案，启动开销可接受（~1秒）。

---

## subagent 工具

```typescript
{
  name: "subagent",
  description: "委托子任务给隔离的Agent进程执行。适合独立任务如代码审查、模块分析等",
  input_schema: {
    type: "object",
    properties: {
      task: { type: "string", description: "子任务描述，需明确输入和期望输出" },
      context: { type: "string", description: "可选的上下文信息（如文件路径、关键代码片段）" }
    },
    required: ["task"]
  }
}
```

---

## 工作流程示例

### 用户请求

```
用户: 审查 src/ 目录下所有 TypeScript 文件的代码质量
```

### 主 Agent 规划

```typescript
// 主 Agent 调用 TodoWrite
{
  items: [
    { content: "列出所有 TypeScript 文件", status: "in_progress", activeForm: "扫描文件中..." },
    { content: "委托子代理审查 utils.ts", status: "pending", activeForm: "审查中..." },
    { content: "委托子代理审查 api.ts", status: "pending", activeForm: "审查中..." },
    { content: "委托子代理审查 types.ts", status: "pending", activeForm: "审查中..." },
    { content: "汇总审查结果", status: "pending", activeForm: "汇总中..." }
  ]
}
```

### 委托子代理

```typescript
// 主 Agent 调用 subagent
{
  task: "审查 utils.ts 的代码质量，检查：1) 命名规范 2) 类型安全 3) 错误处理",
  context: "文件路径: src/utils.ts"
}
```

### 子代理执行

子代理在独立进程中：
1. 读取 `src/utils.ts`
2. 分析代码质量
3. 生成审查报告
4. 返回结果给主 Agent

```
[子代理启动] 审查 utils.ts 的代码质量...

[子代理完成]
## utils.ts 代码审查报告

### 命名规范 ✅
- 函数命名符合 camelCase
- 常量命名符合 UPPER_SNAKE_CASE

### 类型安全 ⚠️
- 第 23 行: 使用了 any 类型
- 建议: 定义具体接口

### 错误处理 ❌
- 第 45 行: 缺少 try-catch
- 建议: 添加错误处理
```

---

## 系统提示的变化

V4 的系统提示增加了委托规则：

```typescript
const SYSTEM = `你是 OpenClaw V4 - 有协调能力的 Agent，工作目录: ${WORKDIR}

## 工作循环
plan -> (delegate -> collect) -> execute -> track -> remember

## 子代理系统 (V4 核心)
工具: subagent - 委托子任务给隔离进程

委托规则:
- 独立子任务用 subagent 委托执行
- 子任务需明确输入和期望输出
- 子代理在隔离进程中运行，返回最终结果
- 适合: 代码审查、独立模块分析、批量处理

## 任务规划系统 (继承 V3)
工具: TodoWrite - 更新任务列表（替换式）
- 复杂任务先用 TodoWrite 创建任务列表
- 最多 20 个任务，同时只能 1 个 in_progress

## 记忆系统 (继承 V2)
- 重要信息用 memory_append 记录
- 相关知识用 memory_search 查找`;
```

---

## 适用场景

### 适合用子代理

| 场景 | 原因 |
|------|------|
| 代码审查 | 每个文件独立，无依赖 |
| 批量处理 | 相同操作，不同输入 |
| 独立分析 | 结果不影响其他任务 |
| 并行搜索 | 多个目录同时搜索 |

### 不适合用子代理

| 场景 | 原因 |
|------|------|
| 需要共享状态 | 子代理上下文隔离 |
| 强依赖关系 | 需要前一步结果 |
| 交互式任务 | 子代理无法与用户交互 |

---

## 代码实现

### 主入口的变化

```typescript
// 主入口支持命令行参数（子代理模式）
if (process.argv[2]) {
  // 子代理模式：执行单个任务后退出
  chat(process.argv[2]).then(console.log).catch(console.error);
} else {
  // 交互模式：REPL 循环
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  // ...
}
```

### 子代理标识

```typescript
// 子代理可以通过环境变量识别自己的身份
const isSubagent = process.env.OPENCLAW_SUBAGENT === "1";
```

---

## 与 V3 的对比

| 特性 | V3 | V4 |
|------|----|----|
| 任务规划 | ✅ TodoManager | ✅ TodoManager |
| 上下文隔离 | ❌ | ✅ 进程隔离 |
| 并行执行 | ❌ | ✅ 可并行 |
| 错误隔离 | ❌ | ✅ 子代理失败不影响主进程 |

---

## 关键洞察

1. **进程递归**: 最简单的隔离方案
2. **同一脚本**: 子代理复用主 Agent 的能力
3. **明确边界**: 子任务需要明确输入输出
4. **适度使用**: 不是所有任务都需要子代理

---

## 下一步

V4 的 Agent 能协调子代理了，但每次都要从头理解任务。V5 将引入 Skill 系统，让 Agent 能加载领域专业知识。
